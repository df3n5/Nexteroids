#include "nxGameScreen.hpp"

#include <nxGameApp/nxNexteroidsGameApp.hpp>
#include <nxActor/nxRockActor.hpp>

const GLfloat NX_LIGHT_POSITION[4] = { 0.0, 5.0, 10.0, 1.0 };
const GLfloat NX_WHITE_LIGHT[] = {1.0, 1.0, 1.0, 1.0};

nxGameScreen::nxGameScreen()
{
	m_RenderDebug = true;
	// Create a pixmap font from a TrueType file.
}

nxGameScreen::~nxGameScreen()
{
}

void nxGameScreen::SetupLighting()
{
	glLightfv(GL_LIGHT0, GL_POSITION, NX_LIGHT_POSITION);
	glLightfv(GL_LIGHT0, GL_SPECULAR, NX_WHITE_LIGHT);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, NX_WHITE_LIGHT);
	glLightfv(GL_LIGHT0, GL_AMBIENT, NX_WHITE_LIGHT);
	glEnable(GL_LIGHT0);

	glEnable(GL_LIGHTING);

}

bool nxGameScreen::InitGL()
{
	/*
	SetupLighting();
	glShadeModel( GL_SMOOTH );
	glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
	glClearDepth( 1000.0f );
	glEnable( GL_DEPTH_TEST );
	glDepthFunc( GL_LEQUAL );
//    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
	glClearColor(0.1, 0.1, 0.5, 0.0);
	glClearAccum(0.1, 0.1, 0.8, 0.0);

	thing1 = glGenLists(1);
	glNewList(thing1, GL_COMPILE);
	glColor3f(1.0, 0.0, 0.0);
	glRectf(-1.0, -1.0, 1.0, 0.0);
	glEndList();
	thing2 = glGenLists(1);
	glNewList(thing2, GL_COMPILE);
	glColor3f(0.0, 1.0, 0.0);
	glRectf(0.0, -1.0, 1.0, 1.0);
	glEndList();

	m_ShipList = glGenLists(1);
	glNewList(m_ShipList, GL_COMPILE);
	glColor3f(0.0, 1.0, 0.0);
		glBegin(GL_TRIANGLES);						// Drawing Using Triangles
			glVertex3f( 0.0f, 1.0f, -2.0f);				// Top
			glVertex3f(-1.0f,-1.0f, -2.0f);				// Bottom Left
			glVertex3f( 1.0f,-1.0f, -2.0f);				// Bottom Right
		glEnd();
	glEndList();

//	glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
//    gluPerspective( 175.0f, (GLfloat)800.0f/(GLfloat)600.0f, 1.0f, 10000.0f );
//	gluPerspective(60.0f,(float)SCREEN_WIDTH/(float)SCREEN_HEIGHT,0.1,600);
	*/

//	const XSize = 640, YSize = 480;
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glOrtho (0, NX_SCREEN_WIDTH, NX_SCREEN_HEIGHT, 0, 0, 1);
	glMatrixMode (GL_MODELVIEW);
	glDisable(GL_DEPTH_TEST);

	m_ShipList = glGenLists(1);
	glNewList(m_ShipList, GL_COMPILE);
	glScalef(20,20,20);
		glBegin(GL_LINE_LOOP);						// Drawing Using Triangles
			glVertex2f( 0.0f,  -1.0f);				// Top
			glVertex2f( -0.5f,  1.0f);				// Bottom Left
			glVertex2f( 0.5f,  1.0f);				// Bottom Right
		glEnd();
	/*
		glBegin(GL_LINE_LOOP);						// Drawing Using Triangles
			glVertex2f( 0.5f,  0.0f);				// Top
			glVertex2f( 0.0f,  2.0f);				// Bottom Left
			glVertex2f( 1.0f,  2.0f);				// Bottom Right
		glEnd();
	*/
	/*
		glBegin(GL_TRIANGLES);						// Drawing Using Triangles
			glVertex2f( 0.5f,  0.0f);				// Top
			glVertex2f( 0.0f,  2.0f);				// Bottom Left
			glVertex2f( 1.0f,  2.0f);				// Bottom Right
		glEnd();
		*/
	glEndList();

}

bool nxGameScreen::Init()
{
	InitGL();

	m_Font = new FTGLPixmapFont ("../../media/font/Abduction III.ttf");

	// If something went wrong, bail out.
	if(m_Font->Error())
	{
		assert(0 && "Font is wrong");
	}

	// Set the font size and render a small text.
	m_Font->FaceSize(32);

	m_Score = 0;
}

void nxGameScreen::VOnUpdate(int deltaMilliseconds)
{

}

float ConvertYToScreen(float y)
{
	return ((float)NX_SCREEN_HEIGHT) - y;
}

void nxGameScreen::DrawBox(nxReal halfSize)
{
	glBegin(GL_LINE_LOOP);
		glVertex2f(-halfSize, -halfSize);
		glVertex2f(halfSize, -halfSize);
		glVertex2f(halfSize, halfSize);
		glVertex2f(-halfSize, halfSize);
	glEnd();
}

void nxGameScreen::DrawPoints(vector<nxPoint3> points)
{
	glBegin(GL_POINTS);
		vector<nxPoint3>::iterator it, itEnd;
		for(it = points.begin(), itEnd = points.end() ; it != itEnd ; it++)
		{
			glVertex2f((*it).GetX(), (*it).GetY());
		}
	glEnd();
}

void nxGameScreen::VOnRenderActor(shared_ptr<nxIActor> actor)
{
//	glTranslatef(0,10,0);

	glPushMatrix();

		
	if(actor->VGetType() == NX_ACTOR_SPACESHIP)
	{

		glTranslatef(actor->VGetPos().GetX(),ConvertYToScreen(actor->VGetPos().GetY()),0);
//		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation() - NX_PI_OVER_2), 0,0,1);
		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation() - NX_PI_OVER_2), 0,0,1);

		/*
		if(m_RenderDebug)
		{
			glPushMatrix();
				DrawBox(20);
			glPopMatrix();
		}
		*/

		glPushMatrix();
			glBegin(GL_POINTS);
//				glVertex2f(actor->VGetPos().GetX(),ConvertYToScreen(actor->VGetPos().GetY()));
				glVertex2f(0,0);
			glEnd();
		glPopMatrix();

		glColor3f(actor->VGetColour().r, actor->VGetColour().g, actor->VGetColour().b);
		glCallList(m_ShipList);
	}
	else if(actor->VGetType() == NX_ACTOR_BULLET)
	{
		glColor3f(actor->VGetColour().r, actor->VGetColour().g, actor->VGetColour().b);
		glTranslatef(actor->VGetPos().GetX(),ConvertYToScreen(actor->VGetPos().GetY()),0);
//		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation() - NX_PI_OVER_2), 0,0,1);

//		float angle = actor->VGetOrientation();
		float radius = actor->GetRadius();

		glBegin(GL_TRIANGLE_FAN);
			glVertex2f(0, 0);
			float angle = 0;
			while(angle<360)
			{
				glVertex2f(sin(angle) * radius, cos(angle) * radius);
				angle += 5.0f;
			}
		glEnd();

			/*
		glPushMatrix();
			glBegin(GL_POINTS);
//				glVertex2f(actor->VGetPos().GetX(),ConvertYToScreen(actor->VGetPos().GetY()));
				glVertex2f(0,0);
			glEnd();
		glPopMatrix();

		glColor3f(actor->VGetColour().r, actor->VGetColour().g, actor->VGetColour().b);
		glCallList(m_ShipList);
		*/
	}
	else if(actor->VGetType() == NX_ACTOR_ROCK)
	{	
		glColor3f(actor->VGetColour().r, actor->VGetColour().g, actor->VGetColour().b);
		glTranslatef(actor->VGetPos().GetX(), ConvertYToScreen(actor->VGetPos().GetY()),0);
//		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation() - NX_PI_OVER_2), 0,0,1);
//		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation() - NX_PI_OVER_2), 0,0,1);
//		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation()), 0,0,1);
		glRotatef( -nx_radians_to_degrees(actor->VGetOrientation()), 0,0,1);

		nxRockActor* castActor = (nxRockActor*)(actor.get());
		vector<nxPoint3> points = castActor->GetPoints();

		if(m_RenderDebug)
		{
			glPushMatrix();
				DrawPoints(points);
			glPopMatrix();
		}

		glBegin(GL_LINE_LOOP);
			vector<nxPoint3>::iterator it, itEnd;
			for(it = points.begin(), itEnd = points.end() ; it != itEnd ; it++)
			{
				stringstream out;
				out<<"Point.GetX() is :"<<(*it).GetX() <<","<<endl;
				out<<"Point.GetY() is :"<<(*it).GetY() <<","<<endl;
				log(NX_LOG_DEBUG, out.str());

				glVertex2f((*it).GetX(), -((*it).GetY()));
			}
		glEnd();
	}

	glPopMatrix();
}

void nxGameScreen::VOnRender()
{

	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);

	glLoadIdentity();					// Reset The Current Modelview Matrix
/*
	glBegin(GL_POINTS);
		glVertex2f(10, 10);
	glEnd();

	glBegin(GL_LINE_LOOP);
//		glVertex2f(20, 20);
		glVertex2f(20, 30); 
		glVertex2f(30, 30);
		glVertex2f(30, 20);
	glEnd();

	glBegin(GL_LINE_LOOP);
		glVertex2f(20, 30); 
		glVertex2f(30, 30);
		glVertex2f(30, 20);
	glEnd();
	*/


//	glTranslatef(5,5,0);

//	glCallList(m_ShipList);

	vector<shared_ptr<nxIActor> >::iterator it, itEnd;
	for(it = m_Actors.begin(), itEnd = m_Actors.end() ; it != itEnd ; it++)
	{
		VOnRenderActor((*it));
	}


	/*
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear The Screen And The Depth Buffer

	glMatrixMode(GL_MODELVIEW);

	glLoadIdentity();					// Reset The Current Modelview Matrix

	glCallList(m_ShipList);

	DoCamera();

    glPushMatrix();

    glScalef(0.8, 0.8, 1.0);

    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(thing1);
    glAccum(GL_LOAD, 0.5);

    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(thing2);
    glAccum(GL_ACCUM, 0.5);

    glAccum(GL_RETURN, 1.0);

    glPopMatrix();
	*/

	stringstream out;
	out<<"Your score : "<<m_Score;
	m_Font->Render(out.str().c_str());

    /* Draw it to the screen */
    SDL_GL_SwapBuffers( );
}



