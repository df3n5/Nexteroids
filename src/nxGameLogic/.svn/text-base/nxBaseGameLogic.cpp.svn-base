#include "nxBaseGameLogic.hpp"
#include <nxEvent/nxEventManager.hpp>
#include <nxEvent/nxLoadingGameEventData.hpp>
#include <nxPhysics/nxPhysics.hpp>

nxBaseGameLogic::nxBaseGameLogic()
{
}

nxBaseGameLogic::nxBaseGameLogic(nxGameOptions const &options)
{
	m_LastActorId = 0;
	m_pProcessManager = NX_NEW nxProcessManager;
//	m_Random.Randomize();
	m_State = NX_GS_Initializing;
	m_bProxy = false;
	m_RenderDiagnostics = false;
	m_NRemotePlayers = 0;
	m_ExpectedRemotePlayers = options.nNetPlayers;
	m_ExpectedAI = 0;
	shared_ptr<nxIPhysics> physics(NX_NEW nxPhysics());
	m_pPhysics = physics;
//	m_pPathingGraph.reset(CreatePathingGraph());

	//TODO : AI
//	m_pAiEventListener = nxEventListenerPtr (NX_NEW nxAiEventListener ( ));
//	safeAddListener(m_pAiEventListener, nxEvtData_AiSteer::sk_EventType);
}


nxBaseGameLogic::~nxBaseGameLogic()
{
	while (!m_GameViews.empty())
	{
		m_GameViews.pop_front();
	}

	NX_SAFE_DELETE(m_pProcessManager);

	//TODO:Actors
//	assert (m_ActorList.empty() && "You should destroy the actor list in the inherited class!");
}

nxActorId nxBaseGameLogic::GetNewActorId()
{
	return (m_LastActorId++);
}

nxActorId nxBaseGameLogic::GetRandomActor(nxActorId ignoreMe)
{
	//TODO:Actors
	return 0;
	/*
	// choose a random element
	unsigned int count = (unsigned int)m_ActorList.size();
	unsigned int choice = m_random.Random(count);

	// since this is a map, we have to walk the tree to find the item in question
	ActorMap::iterator it = m_ActorList.begin();
	for (unsigned int i = 0; i < choice; i++)
	{
		++it;
	}

	// If we're ignoring an actor, choose the next one.  incidentally, this makes the next actor the most likely
	// choice to be chosen, although the player won't notice in a game of a dozen or so actors.
	if (ignoreMe.valid() && it->first == *ignoreMe)
	{
		++it;
		if (it == m_ActorList.end())
		{
			it = m_ActorList.begin();
		}
	}

	// found someone
	return it->first;
	*/
}

//void nxBaseGameLogic::VAddActor(shared_ptr<nxIActor> actor, nxActorParams *p)
void nxBaseGameLogic::VAddActor(shared_ptr<nxIActor> actor)
{
	nxActorId destActorID = actor->VGetId();
	m_ActorList[ destActorID ] = actor;
	actor->VSetId( destActorID );
}

void nxBaseGameLogic::VRemoveActor(nxActorId aid)
{
	if (m_bProxy)
	{
		return;
	}

	if( NULL != VGetActor(aid).get() )
	{
		m_pPhysics->VRemoveActor(aid);
		m_ActorList.erase(aid);
	}
	else
	{
		assert(0 && "Unknown actor!");
	}
}

/*
void nxBaseGameLogic::VMoveActor(const nxActorId id, jfMatrix4_x86 const &mat)
{
	shared_ptr<nxIActor> pActor = VGetActor(id);
	if (pActor)
	{
		pActor->VSetMat(mat);
	}
}
*/

void nxBaseGameLogic::VMoveActor(const nxActorId id, nxPoint3 pos, nxReal orientation)
{
	shared_ptr<nxIActor> actor = VGetActor(id);

	if(actor)
	{
		actor->VSetPos(pos);
		actor->VSetOrientation(orientation);
	}
}

shared_ptr<nxIActor> nxBaseGameLogic::VGetActor(const nxActorId id)
{
	nxActorMap::iterator i = m_ActorList.find(id);
	if (i==m_ActorList.end())
	{
		shared_ptr<nxIActor> null;
		return null;
	}

	return (*i).second;
}

void nxBaseGameLogic::VOnUpdate(int deltaMilliseconds)
{
	switch(m_State)
	{
		case NX_GS_Initializing:
			// If we get to here we're ready to attach players
			VChangeState(NX_GS_MainMenu);
			break;
		case NX_GS_MainMenu:
			// do nothing
			break;
		case NX_GS_LoadingGameEnvironment:
//			nxEventManager::GetInstance().VQueueEvent(nxIEventDataPtr( NX_NEW nxLoadingGameEventData()));
			/*
			if (nxGameApp.getInstance()->VLoadGame())
			{
				VChangeState(NX_BGS_SpawnAI);
			}
			else
			{
				assert(0 && "The game failed to load.");
				g_pApp->AbortGame();
			}
			*/
			break;
		case NX_GS_WaitingForPlayers:
			// do nothing - the game class should handle this one.
			break;
		case NX_GS_SpawnAI:
			if (m_ExpectedAI == 0)
			{
				// the base game logic doesn't spawn AI - your child class will do that.
				// in the case no AI are coming, the base game logic will go ahead and move to
				// the next state.
				VChangeState(NX_GS_Running);
			}
			break;
		case NX_GS_Running:
			m_pProcessManager->UpdateProcesses(deltaMilliseconds);
			break;
		default:
			assert(1 && "Unrecognized state.");
			// Not a bad idea to throw an exception here to
			// catch this in a release build...
	}

	for(int i = 0 ; i < 10 ; i++)
	{
		float32 physicsStep = 1.0f / 60.0f;
		m_pPhysics->VOnUpdate(physicsStep);
	}

	nxGameViewList::iterator i=m_GameViews.begin();
	nxGameViewList::iterator end=m_GameViews.end();
	while (i != end)
	{
		(*i)->VOnUpdate( deltaMilliseconds );
		++i;
	}
}

void nxBaseGameLogic::VChangeState(nxGameState newState)
{
	if (newState==NX_GS_WaitingForPlayers)
	{
		if(m_bProxy)
		{
			//Change to loading state and wait for server to signal game start.
//			VChangeState(NX_GS_LoadingGameEnvironment);

			//Send event to server to signal connect.
			nxEventManager::GetInstance().VQueueEvent( nxIEventDataPtr(NX_NEW nxRemoteClientEventData(m_IpInt)) );
		}
		else
		{
			//Server should wait for clients here.

		}
	}
		/*
		// Get rid of the Main Menu...
		m_GameViews.pop_front();

		// Note: Split screen support would require this to change!
		m_ExpectedPlayers = 1;
		m_ExpectedRemotePlayers = g_pApp->m_pOptions->m_expectedPlayers - 1;
		m_ExpectedAI = g_pApp->m_pOptions->m_numAIs;

		if (!g_pApp->m_pOptions->m_GameHost.empty())
		{
			VSetProxy();
			m_ExpectedAI = 0;			// the server will create these
			m_ExpectedRemotePlayers = 0;	// the server will create these
			ClientSocketManager *pClient = NX_NEW nxClientSocketManager(g_pApp->m_pOptions->m_GameHost, g_pApp->m_pOptions->m_listenPort);
			if (!pClient->Connect())
			{
				// Throw up a main menu
				VChangeState(BGS_MainMenu);
				return;
			}
			g_pApp->m_pBaseSocketManager = pClient;
		}
		else if (m_ExpectedRemotePlayers > 0)
		{
			BaseSocketManager *pServer = NX_NEW BaseSocketManager();
			if (!pServer->Init())
			{
				// Throw up a main menu
				VChangeState(BGS_MainMenu);
				return;
			}

			pServer->AddSocket(new nxGameServerListenSocket(g_pApp->m_pOptions->m_listenPort));
			g_pApp->m_pBaseSocketManager = pServer;
		}
		*/
	/*
	if (newState==NX_BGS_WaitingForPlayers)
	{
		// Get rid of the Main Menu...
		m_GameViews.pop_front();

		// Note: Split screen support would require this to change!
		m_ExpectedPlayers = 1;
		m_ExpectedRemotePlayers = g_pApp->m_pOptions->m_expectedPlayers - 1;
		m_ExpectedAI = g_pApp->m_pOptions->m_numAIs;

		if (!g_pApp->m_pOptions->m_GameHost.empty())
		{
			VSetProxy();
			m_ExpectedAI = 0;			// the server will create these
			m_ExpectedRemotePlayers = 0;	// the server will create these
			ClientSocketManager *pClient = NX_NEW nxClientSocketManager(g_pApp->m_pOptions->m_GameHost, g_pApp->m_pOptions->m_listenPort);
			if (!pClient->Connect())
			{
				// Throw up a main menu
				VChangeState(BGS_MainMenu);
				return;
			}
			g_pApp->m_pBaseSocketManager = pClient;
		}
		else if (m_ExpectedRemotePlayers > 0)
		{
			BaseSocketManager *pServer = NX_NEW BaseSocketManager();
			if (!pServer->Init())
			{
				// Throw up a main menu
				VChangeState(BGS_MainMenu);
				return;
			}

			pServer->AddSocket(new nxGameServerListenSocket(g_pApp->m_pOptions->m_listenPort));
			g_pApp->m_pBaseSocketManager = pServer;
		}
	}
	*/

	m_State = newState;
	if (!m_bProxy)
	{
		nxEventManager::GetInstance().VQueueEvent( nxIEventDataPtr(NX_NEW nxGameStateEventData(m_State)) );
//		nxGameStateEventData gameStateData(m_State);
//		nxEventManager::GetInstance().VTrigger( gameStateData );
	}
}

void nxBaseGameLogic::VBuildInitialScene()
{
	//TODO: Done in script in book.
}

void nxBaseGameLogic::VRenderDiagnostics()
{
	if (m_RenderDiagnostics)
	{
		m_pPhysics->VRenderDiagnostics();
	}
}

void nxBaseGameLogic::TogglePause(bool active)
{
	// TODO This whole body of code belongs in the view, not the game!
	// AND it should fire off a pause event to all listeners.
	/*

	// Pause or resume audio
	if ( active )
	{
		//ResetTimer();
		if (g_pAudio)
		{
			g_pAudio->VPauseAllSounds();
		}
	}
	else
	{
		if (g_pAudio)
		{
			g_pAudio->VResumeAllSounds();
		}
		//SaveBackground();
	}
	*/
}

//Don't generate a view ID, assume it's been set.
void nxBaseGameLogic::VAddViewExplicit(shared_ptr<nxIGameView> pView, int viewId, nxActorId actorId)
{
	m_GameViews.push_back(pView);
	pView->VOnAttach(viewId, actorId);
	pView->VOnRestore();
}

void nxBaseGameLogic::VAddView(shared_ptr<nxIGameView> pView, nxActorId actorId)
{
	// This makes sure that all views have a non-zero view id.
	int viewId = static_cast<int>(m_GameViews.size());
	m_GameViews.push_back(pView);
	pView->VOnAttach(viewId, actorId);
	pView->VOnRestore();
}

void nxBaseGameLogic::VRemoveView(shared_ptr<nxIGameView> pView)
{
	m_GameViews.remove(pView);
}

