#include "nxEventManager.hpp"

nxEventManager nxEventManager::m_Instance;

nxEventManager::nxEventManager()
	:
		nxIEventManager(),
		m_ActiveQueue(0)
{
}

nxEventManager::~nxEventManager()
{
	m_ActiveQueue = 0;
}

nxEventManager& nxEventManager::GetInstance()
{
	//static nxEventManager m_Instance;
	//return m_Instance;
	return nxEventManager::m_Instance;
}

nxEventListenerMap::iterator nxEventManager::FindAndAddListenerMapEntry(nxEventListenerMap::iterator listenerMapEntry, nxEventType eventType)
{
	nxEventListenerMap::iterator listenerEntry = listenerMapEntry;
	//Add listener to registry if not found already
	if ( listenerEntry == m_ListenerRegistry.end() )
	{
		nxEventListenerMapInsertRes insertElem = m_ListenerRegistry.insert(
			nxEventListenerMapEnt( eventType,
								  nxEventListenerTable() ) );

		if ( insertElem.second == false )
		{
			assert(0);
//			return false;
		}

		if ( insertElem.first == m_ListenerRegistry.end() )
		{
			assert(0);
//			return false;
		}

		// store it so we can update the mapped list next ...
		listenerEntry = insertElem.first;
	}
	return listenerEntry;
}

bool nxEventManager::IsListenerInTable(nxEventListenerPtr listener, nxEventListenerTable& listenerTable)
{
	//Look for listener in event listener table for event type
	for ( nxEventListenerTable::iterator it2 = listenerTable.begin(),
			  it2End = listenerTable.end(); it2 != it2End ; it2++ )
	{
		bool bListenerMatch = ( *it2 == listener );

		if ( bListenerMatch )
		{
			return true;
		}
	}
	return false;
}


bool nxEventManager::VAddListener ( nxEventListenerPtr const & inListener,
		nxEventType const & inType )
{
	if ( ! VValidateType( inType ) )
	{
		return false;
	}

	nxEventListenerMap::iterator listenerMapEntry = m_ListenerRegistry.find( inType );
	listenerMapEntry = FindAndAddListenerMapEntry(listenerMapEntry, inType);

/*
	//Add listener to registry if not found already
	if ( it == m_ListenerRegistry.end() )
	{
		nxEventListenerMapInsertRes insertElem = m_ListenerRegistry.insert(
			nxEventListenerMapEnt( inType,
								  nxEventListenerTable() ) );

		if ( insertElem.second == false )
		{
			return false;
		}

		if ( insertElem.first == m_ListenerRegistry.end() )
		{
			return false;
		}

		// store it so we can update the mapped list next ...
		it = insertElem.first;
	}
*/

	// note: use reference to make following code more simple
	nxEventListenerTable & listenerTable = (*listenerMapEntry).second;

	if( IsListenerInTable(inListener, listenerTable) )
	{
		return false;
	}
	else
	{
		// okay, event type validated, event listener validated,
		// event listener not already in map, add it
		listenerTable.push_back( inListener );
		return true;
	}
/*
	//Look for listener in event listener table for event type
	for ( nxEventListenerTable::iterator it2 = listenerTable.begin(),
			  it2End = listenerTable.end(); it2 != it2End ; it2++ )
	{
		bool bListenerMatch = ( *it2 == inListener );

		if ( bListenerMatch )
		{
			return false;
		}
	}
*/

}

//
// nxEventManager::VDelListener		- Chapter 10, page 292
//
// Remove a listener/type pairing from the internal tables
//
// Returns false if the pairing was not found.
//
bool nxEventManager::VDelListener (
	nxEventListenerPtr const & inListener, nxEventType const & inType )
{
	if ( ! VValidateType( inType ) )
	{
		return false;
	}

	bool rc = false;

	// brute force method, iterate through all existing mapping
	// entries looking for the matching listener and remove it.
	for ( nxEventListenerMap::iterator it = m_ListenerRegistry.begin(),
			  itEnd = m_ListenerRegistry.end(); it != itEnd; it++ )
	{
		nxEventListenerTable & table = it->second;

		for ( nxEventListenerTable::iterator it2 = table.begin(),
				  it2End = table.end(); it2 != it2End; it2++ )
		{
			if ( *it2 == inListener )
			{
				// found match, remove from table,
				table.erase( it2 );

				// update return code
				rc = true;

				// and early-quit the inner loop as addListener()
				// code ensures that each listener can only
				// appear in one event's processing list once.
				break;
			}
		}
	}

	return rc;
}

//
// nxEventManager::VTrigger		- Chapter 10, page 293
//
// Fire off event - synchronous - do it NOW kind of thing -
// analogous to Win32 SendMessage() API.
//
// returns true if the event was consumed, false if not. Note
// that it is acceptable for all event listeners to act on an
// event and not consume it, this return signature exists to
// allow complete propogation of that shred of information from
// the internals of this system to outside uesrs.
//
bool nxEventManager::VTrigger (
	nxIEventData const & inEvent ) const
{
	if ( ! VValidateType( inEvent.VGetEventType() ) )
	{
		return false;
	}

	//Iterate through listeners which listen to all events, such as a snooper.
	nxEventListenerMap::const_iterator itWC = m_ListenerRegistry.find( NX_EVENT_MANAGER_GLOBAL_LISTENER_IDX );

	if ( itWC != m_ListenerRegistry.end() )
	{
		nxEventListenerTable const & table = itWC->second;

		bool processed = false;

		for ( nxEventListenerTable::const_iterator it2 = table.begin(),
				  it2End = table.end(); it2 != it2End; it2++ )
		{
			(*it2)->HandleEvent( inEvent );
		}
	}

	//Now iterate through listeners which specifically register for certain events
	nxEventListenerMap::const_iterator it =
		m_ListenerRegistry.find( inEvent.VGetEventType() );

	if ( it == m_ListenerRegistry.end() )
	{
		return false;
	}

	nxEventListenerTable const & table = it->second;

	bool processed = false;

	for ( nxEventListenerTable::const_iterator it2 = table.begin(),
			  it2End = table.end(); it2 != it2End; it2++ )
	{
		nxEventListenerPtr listener = *it2;
		if ( listener->HandleEvent( inEvent ) )
		{
			// only set to true, if processing eats the messages
			processed = true;
		}
	}

	return processed;
}

bool nxEventManager::VQueueEvent ( nxIEventDataPtr const & inEvent )
{
	/*
	assert ( m_ActiveQueue >= 0 );
	assert ( m_ActiveQueue < NX_EVENT_MANAGER_K_NQUEUES );

	if ( ! VValidateType( inEvent->VGetEventType() ) )
	{
		return false;
	}

	nxEventListenerMap::const_iterator it =
		m_ListenerRegistry.find( inEvent->VGetEventType() );

	if ( it == m_ListenerRegistry.end() )
	{
		// if global listener is not active, then abort queue add
		nxEventListenerMap::const_iterator itWC = m_ListenerRegistry.find( NX_EVENT_MANAGER_GLOBAL_LISTENER_IDX
				);
		if ( itWC == m_ListenerRegistry.end() )
		{
			// no listeners for this event, skip it
			return false;
		}
	}
	*/
	m_EventQueues[m_ActiveQueue].push_back( inEvent );
	return true;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  VAbortEvent
 *  Description:  Abort first event of given type, or all of them if the option is set.
 * =====================================================================================
 */
bool nxEventManager::VAbortEvent ( nxEventType const & inType, bool
		allOfType )
{
	assert ( m_ActiveQueue >= 0 );
	assert ( m_ActiveQueue < NX_EVENT_MANAGER_K_NQUEUES );
	if ( ! VValidateType( inType ) )
	{
		return false;
	}
	nxEventListenerMap::iterator it = m_ListenerRegistry.find(
			inType );
	if ( it == m_ListenerRegistry.end() )
	{
		return false; // no listeners for this event, skip it
	}

	bool rc = false;
	nxEventQueue &evtQueue = m_EventQueues[m_ActiveQueue];
	for ( nxEventQueue::iterator it = evtQueue.begin(),
			itEnd = evtQueue.end(); it != itEnd; it++ )
	{
		if ( (*it)->VGetEventType() == inType )
		{
			it = evtQueue.erase(it);
			rc = true;
			if ( !allOfType )
			{
				break;
			}
		}
		else
		{
			++it;
		}
	}
	return rc;
}

bool nxEventManager::VTick ( unsigned long maxMillis )
{
    jfFPSTimer timer;
    timer.Start();
	unsigned long curMs = 0;
	unsigned long maxMs =
		( maxMillis == nxIEventManager::NX_IEVENT_MANAGER_K_INFINITE ) ?
		nxIEventManager::NX_IEVENT_MANAGER_K_INFINITE
		: (curMs + maxMillis );
	nxEventListenerMap::const_iterator itWC = m_ListenerRegistry.find( NX_EVENT_MANAGER_GLOBAL_LISTENER_IDX );
	
	// swap active queues, make sure new queue is empty after the swap ...
	int queueToProcess = m_ActiveQueue;
	m_ActiveQueue = ( m_ActiveQueue + 1 ) % NX_EVENT_MANAGER_K_NQUEUES;
	m_EventQueues[m_ActiveQueue].clear();
	
	// now process as many events as we can ( possibly time
	//limited ) ...
	// always do AT LEAST one event, if ANY are available ...
	while ( m_EventQueues[queueToProcess].size() > 0 )
	{
		nxIEventDataPtr event = m_EventQueues[queueToProcess].front();
		m_EventQueues[queueToProcess].pop_front();
		nxEventType const & eventType = event->VGetEventType();
		nxEventListenerMap::const_iterator itListeners =
			m_ListenerRegistry.find( eventType );
		//Go through listeners which process all events first.
		//TODO: Is this needed?
		/*
		if ( itWC != m_ListenerRegistry.end() )
		{
			nxEventListenerTable const & table = itWC->second;
			bool processed = false;
			for ( nxEventListenerTable::const_iterator
					it2 = table.begin(), it2End = table.end();
					it2 != it2End; it2++ )
			{
				(*it2)->HandleEvent( *event );
			}
		}
		*/
		// skip if listener doesn't exist for this type
		if ( itListeners == m_ListenerRegistry.end() )
		{
			continue;
		}
		nxEventListenerTable const & table = itListeners->second;

		//Let all events in table handle event.
		for ( nxEventListenerTable::const_iterator
				it = table.begin(), end = table.end();
				it != end ; it++ )
		{
			if ( (*it)->HandleEvent( *event ) )
			{
				continue;
			}
		}

		//Check to see if time is up
		curMs = timer.GetTicks();
		if ( maxMillis != nxIEventManager::NX_IEVENT_MANAGER_K_INFINITE )
		{
			if ( curMs >= maxMs )
			{
				// time ran about, abort processing loop
				break;
			}
		}
	}
	//if any events left to process, push them onto the active
	//	queue.
	//		Note: to preserve sequencing, go bottom-up on the
	//		remainder, inserting them at the head of the active
	//		queue...
	bool queueFlushed = ( m_EventQueues[queueToProcess].size() == 0 );
	if ( !queueFlushed )
	{
		while ( m_EventQueues[queueToProcess].size() > 0 )
		{
			nxIEventDataPtr event = m_EventQueues[queueToProcess].back();
			m_EventQueues[queueToProcess].pop_back();
			m_EventQueues[m_ActiveQueue].push_front( event );
		}
		queueFlushed = true;
	}
	// all done, this pass
	return queueFlushed;
}

bool nxEventManager::VValidateType( nxEventType const & inType )
	const
{
	/*
	if ( 0 == inType.getStr().length() )
	{
		return false;
	}
	//Wildcard types are not valid.
	if ( ( inType.GetHashValue() == NX_EVENT_MANAGER_GLOBAL_LISTENER_IDX ) &&
			(strcmp(inType.getStr().c_str(), NX_IEVENT_MANAGER_K_PWILDCARD_EVENT_TYPE) !=
			 0) )
	{
		return false;
	}
	EventTypeSet::const_iterator evIt =
		m_typeList.find( inType
				);
	if ( evIt == m_typeList.end() )
	{
		assert( 0 && "Failed validation of an event type; it was probably not registered with the EventManager!" );
		return false;
	}
	*/
	//Just check it is in enum somewhere.
	if((inType >= 0) && (inType < NX_EVENT_Endsentinal)) 
	{
		return true;
	}
	else
	{
		return false;
	}
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  GetListenerList
 *  Description:  Get the list of listeners associated with a specific event type
 * =====================================================================================
 */
nxEventListenerList nxEventManager::GetListenerList (
	nxEventType const & eventType ) const
{
	if ( ! VValidateType( eventType ) )
	{
		return nxEventListenerList();
	}

	nxEventListenerMap::const_iterator itListeners =
		m_ListenerRegistry.find( eventType );

	// no listerners currently for this event type, so sad
	if ( itListeners == m_ListenerRegistry.end() )
	{
		return nxEventListenerList();
	}

	nxEventListenerTable const & table = itListeners->second;

	// there was, but is not now, any listerners currently for
	// this event type, so sad
	if ( table.size() == 0 )
	{
		return nxEventListenerList();
	}

	nxEventListenerList result;

	result.reserve( table.size() );

	for ( nxEventListenerTable::const_iterator it = table.begin(),
			  end = table.end(); it != end ; it++ )
	{
		result.push_back( *it );
	}

	return result;
}
